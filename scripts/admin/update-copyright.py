____________________________________________________________________________________

# Pyomo: Python Optimization Modeling Objects
# Copyright (c) 2008-2026 National Technology and Engineering Solutions of Sandia, LLC
# Under the terms of Contract DE-NA0003525 with National Technology and Engineering
# Solutions of Sandia, LLC, the U.S. Government retains certain rights in this
# software.  This software is distributed under the 3-clause BSD License.
# ____________________________________________________________________________________

# Note: When using this script there are 2 files that need special handling
#
# 1. `pyomo/dataportal/_parse_table_datacmds.py` is autogenerated and should NOT
#    include the copyright statement
# 2. `pyomo/contrib/ampl_function_demo/src/functions.c` needs to be updated manually
#    because the script tries to prematurely close the comment
#
# See the discussion in PR #3846 for more information

import glob
import os
import sys

LOOKAHEAD = 25

UNDERBARS = '_______________'
DASHES = '---------------'
HASHES = '###############'

base_copyright = """
____________________________________________________________________________________

Pyomo: Python Optimization Modeling Objects
Copyright (c) 2008-2026 National Technology and Engineering Solutions of Sandia, LLC
Under the terms of Contract DE-NA0003525 with National Technology and Engineering
Solutions of Sandia, LLC, the U.S. Government retains certain rights in this
software.  This software is distributed under the 3-clause BSD License.
____________________________________________________________________________________
""".strip()


def shell_copyright():
    txt = (
        '\n'.join([('# ' + line).rstrip() for line in base_copyright.splitlines()])
        + '\n'
    )
    # Text, number of lines in the copyright block, extra lines after
    # the trailing UNDERBARS
    return txt, len(txt.splitlines()), 0


def c_copyright():
    txt = (
        '\n'.join([('// ' + line).rstrip() for line in base_copyright.splitlines()])
        + '\n'
    )
    # Text, number of lines in the copyright block, extra lines after
    # the trailing UNDERBARS
    return txt, len(txt.splitlines()), 0


def cpp_copyright():
    txt = (
        '/**'
        + '\n'.join([(' * ' + line).rstrip() for line in base_copyright.splitlines()])[
            3:
        ]
        + '\n**/\n'
    )
    # Text, number of lines in the copyright block, extra lines after
    # the trailing UNDERBARS
    return txt, len(txt.splitlines()), 1


copyright = {
    'CMakeLists.txt': shell_copyright(),
    '.cmake': shell_copyright(),
    '.sh': shell_copyright(),
    '.py': shell_copyright(),
    '.h': c_copyright(),
    '.c': c_copyright(),
    '.hpp': cpp_copyright(),
    '.cpp': cpp_copyright(),
    '.hxx': cpp_copyright(),
    '.cxx': cpp_copyright(),
}

FTYPE = None
if len(sys.argv) > 1:
    if sys.argv[1].startswith('--type='):
        FTYPE = sys.argv.pop(1).split("=")[1]
        ftype = FTYPE

filelist = list(reversed(sys.argv[1:]))

while filelist:
    filename = filelist.pop()
    if not os.path.exists(filename):
        print(f"ERROR: {filename} does not exist; skipping")
        continue
    if os.path.isdir(filename):
        filelist.extend(glob.glob(os.path.join(filename, '*')))
        continue
    if not os.path.isfile(filename):
        print(f"WARNING: {filename} is not a file or directory; skipping")
        continue

    if not FTYPE:
        ftype = os.path.splitext(filename)[1]
    if ftype not in copyright:
        if os.path.basename(filename) in copyright:
            ftype = os.path.basename(filename)
        else:
            print("ERROR: Unknown file type: %s (for %s)" % (ftype, filename))
            continue

    try:
        with open(filename, 'r') as FILE:
            data = FILE.readlines()
    except:
        print("ERROR: Failed to open file '%s'\n" % (filename,))
        continue

    dLen = len(data)
    shebang = ''
    if dLen and data[0].strip().startswith('#!'):
        shebang = data.pop(0).strip() + "\n"
        dLen -= 1
    if dLen and '-*-' in data[0]:
        shebang += data.pop(0).strip() + "\n"
        dLen -= 1

    firstSep = lastSep = None
    for separator in (UNDERBARS, DASHES, HASHES):
        for linenum, line in enumerate(data[: min(LOOKAHEAD, dLen)]):
            if separator in line:
                firstSep = linenum
                if ftype in ('.h', '.c') and line.strip().startswith('/*'):
                    ftype += 'pp'
                break
        if firstSep is None:
            continue
        for linenum, line in enumerate(
            data[firstSep + 1 : min(firstSep + LOOKAHEAD, dLen)]
        ):
            if separator in line:
                lastSep = firstSep + linenum + 1
                break
        if lastSep is not None:
            lastSep += copyright[ftype][2]
            break

    if lastSep is None:
        print("WARNING: %s: copyright separator not found." % (filename,))
    else:
        if separator != UNDERBARS:
            print(
                "WARNING: %s: copyright separator found, but was "
                "not UNDERBARS." % (filename,)
            )
        if lastSep - firstSep != copyright[ftype][1] - 1:
            print(
                "WARNING: %s: inconsistent line count in existing "
                "copyright block." % (filename,)
            )

    with open(filename, 'w') as FILE:
        if shebang:
            FILE.write(shebang)
        if firstSep:
            FILE.write(''.join(data[:firstSep]))
        FILE.write(copyright[ftype][0])
        if lastSep:
            FILE.write(''.join(data[lastSep + 1 :]))
        elif firstSep:
            FILE.write(''.join(data[firstSep + 1 :]))
        else:
            FILE.write(''.join(data))

        if data:
            if not (
                data[-1].endswith('\n')
                or data[-1].endswith('\r\n')
                or data[-1].endswith('\r')
            ):
                FILE.write("\n")
