
\chapter{Pyomo Solver Interfaces}
\label{chap:solvers} % Always give a unique label
% use \chaptermark{}
% to alter or adjust the chapter heading in the running head

\abstract{Pyomo supports interfaces to external solvers, and it 
includes packages that define meta-solvers tailored to specific 
classes of problems (e.g. stochastic programs).  
This chapter provides an overview of Pyomo's solver interfaces, and it illustrates
how to apply different types of solvers.  This includes examples of the Pyomo command
as well as Python scripts.}


\section{Solvers and Solver Managers}
\label{sec:solvers:interfaces}

Pyomo uses \textit{solver managers} to execute \textit{solvers} that perform
optimization and other forms of model analysis.  Solver managers support a flexible mechanism
for asyncronously executing solvers either locally or remotely.  The
following solver managers are available in Pyomo:
\begin{itemize}

\item \code{neos}: Asynchronously execute solvers on the NEOS server

\item \code{phpyro}: Specialized PH solver manager that uses \code{pyro} to execute solvers remotely

\item \code{pyro}: Execute solvers remotely using \code{pyro}

\item \code{serial}: Synchronously execute solvers locally

\end{itemize}
If no solver manager is specified, Pyomo uses the \code{serial} solver
manager to execute solvers locally.  The \code{pyro} and \code{phpyro} solver
managers require the installation and configuration of the \code{pyro}
software.  The \code{neos} solver manager is used to remotely execute solvers on the
NEOS optimization server.

Pyomo models can be analyzed with a wide variety of optimization
solvers.  The \code{pyomo.opt}\index{pyomo.opt package@\code{pyomo.opt}
package} package manages interfaces to optimization solvers, which
are typically defined outside of Pyomo.  There are several types
of solver interfaces in Pyomo:
\begin{itemize}

\item A \textit{shell solver} is launched as a separate sub-process
by running an executable found on the user's \code{PATH} environment.
Pyomo interfaces with these solvers through files;  Pyomo generates
a file description of the problem, launches the solver, and then
loads the results from log files and standard output files.  This
is a common form of solver.

\item A \textit{direct solver} is executed as a subroutine.  Pyomo
interfaces with these solvers through libraries that are installed
and exposed in the form of Python packages.  This is an uncommon
form of solver, since it relies on Python interfaces to solver
libraries.

\item A \textit{meta-solver} is a Python script that executes
one-or-more other solvers.  These solvers are directly integrated
into Pyomo, and they execute sub-solvers to perform optimization.
Meta-solvers can support the application of sub-solvers to sub-problems,
and they also provide a simple way of interfacing to other classes
of solvers (e.g. OpenOpt and ASL solvers).

\end{itemize}
Tables~\ref{table:solvers:interfaces} and~\ref{table:solvers:metasolvers}
summarizes the solver interfaces that are supported in Pyomo~\PyomoVersion.
Table~\ref{table:solvers:interfaces} describes shell solvers and direct solvers, which are distinguished
here by the type of I/O that is used to perform optimization:\index{solver I/O type}
\begin{itemize}

\item {\bf bar}: \index{solver I/O type!bar}\index{bar file@\code{.bar} file}\index{filename extension!bar@\code{.bar} BARON BAR}The solver optimizes a BAR file that is generated by Pyomo, and the logfile and other output files generated by the are parsed to create the solver results object.

\item {\bf lp}: \index{solver I/O type!lp}\index{lp file@\code{.lp} file}\index{filename extension!lp@\code{.lp} CPLEX LP}The solver optimizes an LP file that is generated by Pyomo, and the logfile and other output files generated by the solver are parsed to create the solver results object.

\item {\bf mps}: \index{solver I/O type!mps}\index{lp file@\code{.mps} file}\index{filename extension!lp@\code{.lp} FREE FORMAT MPS}The solver optimizes an MPS file that is generated by Pyomo, and the logfile and other output files generated by the solver are parsed to create the solver results object.

\item {\bf nl}: \index{solver I/O type!nl}\index{nl file@\code{.nl} file}\index{filename extension!nl@\code{.nl} AMPL NL}The solver optimizes an NL file that is generated by Pyomo, and the SOL file generated by the solver is process to create the solver results object.

\item {\bf python}: \index{solver I/O type!python}Pyomo directly interacts with the solver through a Python interface.  No explicit file I/O is required.

\end{itemize}
The \code{python} I/O type denotes a direct solver, and other I/O
types denote a shell solver;  a solver library may support both
modes of communication.  The \code{lp} and \code{bar} I/O types can
provide a lot of detail about the optimization process, though the
logfile parsing can be fragile.  The \code{nl} I/O type allows Pyomo
to leverage any solver that has been built with the AMPL Solver
Library\index{AMPL Solver Library}.  However, this I/O type provides
limited detail about the optimization process.

\begin{table}
\begin{center}
\begin{tabular}{|l|c|c|c|c|p{9cm}|} \hline
Name & \multicolumn{4}{c|}{I/O type} & Description \\
        & bar & lp & nl & python & \\ \hline \hline
baron   &   x &    &    &         & The BARON LP/MINLP solver\indexsolver{BARON}\\
cbc     &     &  x &  x &         & The CBC LP/MIP solver\indexsolver{CBC}\\
cplex   &     &  x &  x &       x & The CPLEX LP/MIP solver\indexsolver{CPLEX}\\
glpk    &     &  x &    &         & The GLPK LP/MIP solver\indexsolver{GLPK}\\
gurobi  &     &  x &  x &       x & The GUROBI LP/MIP solver\indexsolver{GUROBI}\\
path    &     &    &  x &         & The PATH complementarity solver\indexsolver{PATH}\\
pico    &     &  x &  x &         & The PICO LP/MIP solver\indexsolver{PICO}\\
scip    &     &    &  x &         & The SCIP LP/MIP solver\indexsolver{SCIP}\\
xpress  &     &  x &    &         & The XPRESS LP/MIP solver\indexsolver{XPRESS}\\ \hline
\end{tabular}
\end{center}
\caption{\label{table:solvers:interfaces} Solver interfaces supported by Pyomo, with a summary of the I/O types that they support.}
\end{table}


\begin{table}
\begin{center}
\begin{tabular}{|l|p{10cm}|} \hline
Name        & Description \\ \hline \hline
asl         & Interface for solvers using the AMPL Solver Library\\
mpec\_minlp & Solver that transforms a MPEC to a MINLP\\
mpec\_nlp   & Solver that transforms a MPEC to a NLP\\
openopt     & Interface to OpenOpt solvers\\
py          & Direct python solver interfaces\\ \hline
\end{tabular}
\end{center}
\caption{\label{table:solvers:metasolvers} Meta-solvers supported by Pyomo.}
\end{table}


\section{Using the \code{pyomo} Command}

\subsection{Local Solvers}

Consider the following linear optimization problem, which will be used in the following examples:
\listing{pyomo/examples/doc/pyomobook/ref-solvers/simple.py}{}{1}{9}
The \code{pyomo} command can optimize this problem using the \code{solve} subcommand:
\datalisting{pyomo/examples/doc/pyomobook/ref-solvers/example1.sh}{cmd}{4}{4}
The \code{--solver} option specifies the name of the solver that is executed.  If the \code{--solver-manager} option is omitted, then this solver is executed on the local machine.  
The \code{--solver-io} option can be used to specify the I/O type, when multiple types are supported.\index{pyomo command@\code{pyomo} command!argument, \code{--solver-io}} For example, the default I/O type for CBC is \code{lp}, and the following command executes CBC with the \code{nl} I/O type:
\datalisting{pyomo/examples/doc/pyomobook/ref-solvers/example2.sh}{cmd}{4}{4}

Meta-solvers can be specified with the \code{--solver} option, and the sub-solver is specified with the 
\code{--solver-options} option:
\datalisting{pyomo/examples/doc/pyomobook/ref-solvers/example100.sh}{cmd}{4}{5}
Many meta-solvers use a single sub-solver.  Pyomo supports a special syntax for meta-solvers that supports this case: \textless meta-solver\textgreater:\textless sub-solver\textgreater.  For example:
\datalisting{pyomo/examples/doc/pyomobook/ref-solvers/example101.sh}{cmd}{4}{4}
Pyomo also treats the \code{asl} meta-solver as the default interface for shell solvers that do not have predefined solver interfaces.  For example:
\datalisting{pyomo/examples/doc/pyomobook/ref-solvers/example102.sh}{cmd}{4}{4}
The solver \code{ipopt} does not have a predefined solver interface in Pyomo.  When this solver is specified,
Pyomo treats this as the sub-solver for the \code{asl} meta-solver.  
Pyomo searches the user's \code{PATH} environment for the \code{ipopt} executable.  If found, this executable is used by the \code{asl} meta-solver, which assumes that that executable is an ASL-compatible solver.

The \code{python} I/O type is used to specify a direct solver:
\datalisting{pyomo/examples/doc/pyomobook/ref-solvers/example200.sh}{cmd}{4}{4}
The \code{py} meta-solver can also be used to specify a direct solver without using the \code{--solver-io} option:
\datalisting{pyomo/examples/doc/pyomobook/ref-solvers/example201.sh}{cmd}{4}{4}

\subsection{Remote Solvers}

The \code{--solver-manager} option is used to specify the solver
manager that is used to execute solvers.  Although the default
solver manager executes locally, solver managers were developed to
managed the remote execution of solvers.  Conceptually, a solver
manager is used to queue an asynchronous solver request.  The solver
manager can queue multiple solver requests, evaluate their status,
and collect solver results.  Queueing a solver request simply
involves passing the solver name and options to the solver manager.
However, some options may be interpreted differently, and different
solver managers may support different solvers.

The \code{neos} solver manager supports remote execution of solvers
on the NEOS server~\cite{CzyMesMor98}.  Pyomo has adapted the Kestrel
interface to NEOS~\cite{NEOS}, which supports remote execution of
NEOS solvers with ASL \code{.nl} files.  Kestrel uses an XML-based
remote procedure call protocol to send files to and from the NEOS
server.

Consider the following example:
\datalisting{pyomo/examples/doc/pyomobook/ref-solvers/example300.sh}{cmd}{4}{4}
This command generates output like the following:
\datalisting{pyomo/examples/doc/pyomobook/ref-solvers/example300.log}{}{1}{20}
The \code{neos} solver manager submits a request to the NEOS server,
the server queues this request in a Condor pool, and it generats a
temporary web page where the user can view the current solver output.
Pyomo waits for the NEOS server to return the solver output files,
which are processed as if the solver executed locally.

The \code{pyomo help} sub-command prints a list of sub-solvers that can be
executed by NEOS through the Kestrel interface:
\datalisting{pyomo/examples/doc/pyomobook/ref-solvers/example301.sh}{cmd}{4}{4}



\section{Optimization in Python Scripts}

\subsection{Performing Optimization}

The following example is a very simple Python script that loads a
model, performs optimization and prints the results:
\listing{pyomo/examples/doc/pyomobook/ref-solvers/example400.py}{}{1}{14}
The \code{SolverFactory} function is used to construct a solver
object, and the argument to this function is the same as is used with the
\code{--solver} options described above.  For example, the \code{asl:ipopt}
solver can be specified:
\listing{pyomo/examples/doc/pyomobook/ref-solvers/example401.py}{solver}{6}{6}
This constructs an \code{asl} meta-solver with the \code{ipopt} sub-solver.
The I/O type used by the solver can be specified with the \code{solver\_io} keyword argument:
\listing{pyomo/examples/doc/pyomobook/ref-solvers/example402.py}{}{1}{14}

The \code{solve()} method accepts a variety of standard keyword arguments:
\begin{itemize}

\item \code{logfile}:   The filename used to store output for shell solvers.

\item \code{solnfile}:  The filename used to store the solution for shell solvers.

\item \code{load\_solutions}: If this argument is \code{True} (the default), then solutions are 
stored in the model.  If \code{False}, then the results object keeps a \textit{raw} representation of 
the solutions.

\item \code{timelimit}: The number of seconds that a shell solver is run before it is terminated.  (default is \code{None})

\item \code{report\_timing}: If this argument is \code{True}, then timing information is report by the solver (default is \code{False})

\item \code{tee}: If this argument is \code{True}, then the solver output is both printed to the standard output as well as saved to the log file.  If \code{False} (the default), then the solver output is only
saved to the log file.

\item \code{suffixes}: A list of suffixes that are exported to the solver.

\end{itemize}
All other keyword arguments will be passed as options to the solver.
The \code{options} attribute can also be used to specify these
\textit{solver options}.  For example:
\spacedlisting{pyomo/examples/doc/pyomobook/ref-solvers/example403.py}{load}{5}{14}
When both keyword arguments and solver options are specified, the
keyword arguments temporarily override the value.  We can extend the previous example to illustrate this:
\spacedlisting{pyomo/examples/doc/pyomobook/ref-solvers/example404.py}{load}{9}{22}
The second execution of \code{GLPK} uses the \code{steep} option and the \code{seed} option with value \code{1234567890}.
The previous examples illustrate that the \code{None} option value is used to specify a 
command-line option without a value (i.e. \code{--steep})..

\subsection{Managing Solutions}

In these examples, the optimizer immediately loads results into the
model.  This consists of three steps: (1) storing solutions in the
\code{solutions} attribute of the model, (2) load the values of
variables from a selected solution, and (3) remove solutions from the results object.
Afterwards, the \code{results} object only contains
meta-data about information about the model and the optimization
process.  

The \code{select} keyword argument can be used to specify the solution that is used to load the
values of variables:
\if 0
WEH - Do we have a solver that returns multiple solutions?  If so, we should use that
to test this example.
\fi
\spacedlisting{pyomo/examples/doc/pyomobook/ref-solvers/example500.py}{load1}{8}{9}
Loading of solutions can be disabled with the \code{load\_solutions} keyword argument:
\spacedlisting{pyomo/examples/doc/pyomobook/ref-solvers/example500.py}{load2}{15}{16}
When this argument is specified, the results object contains
\textit{raw} results data, which is generally not suitable for human
consumption.  One reason for explicitly loading 
solutions is to better control how they are loaded.
\spacedlisting{pyomo/examples/doc/pyomobook/ref-solvers/example500.py}{load3}{22}{25}

The \code{load\_from} method for model solutions accepts the following arguments:
\begin{itemize}

\item \textbf{allow\_consistent\_values\_for\_fixed\_vars}: If this
argument is \code{False} (the default), then an error occurs if a value is given for a fixed
variable in the model.  If \code{True}, then an error only occurs if a value is given for a fixed value that differs from the value in the model.

\item \textbf{comparison\_tolerance\_for\_fixed\_vars}: The tolerance value used to decide if fixed values differ.  (default is $10^{-5}$).

\item \textbf{ignore\_invalid\_labels}: If this argument is \code{False} (the default), then an error occurs if a value is given for a variable that is not in the model.  If \code{True}, then invalid variable labels are ignored.

\item \textbf{id}: If this argument is \code{None} (the default), then all solutions are loaded from the results object.  Otherwise, this specifies the solution index that is loaded.

\item \textbf{clear}: If this argument is \code{True} (the default), then all solutions the model are cleared before new solutions are loaded.

\item \textbf{default\_variable\_value}: If this argument is not \code{None} (the default), then 
undefined, non-fixed variables in the model are assigned this value.

\item \textbf{select}: This argument is the index for the solution that is used to load variable values in the model. (default 0)

\item \textbf{ignore\_fixed\_vars}: If this argument is \code{True} (the default), then fixed variables are ignored when loading variable values in the model.

\end{itemize}
The \code{select()} method for model solutions can be used to load a different solution into the variable:
\spacedlisting{pyomo/examples/doc/pyomobook/ref-solvers/example500.py}{load4}{31}{34}
This method supports similar keyword arguments with the same default
values:\\
\mbox{\hspace{0.5in}}\code{allow\_consistent\_values\_for\_fixed\_vars},\\
\mbox{\hspace{0.5in}}\code{comparison\_tolerance\_for\_fixed\_vars},\\
\mbox{\hspace{0.5in}}\code{ignore\_invalid\_labels}, and\\
\mbox{\hspace{0.5in}}\code{ignore\_fixed\_vars}.

The \code{store\_to} method for model solutions saves the values of model variables into a results object.  For example:
\spacedlisting{pyomo/examples/doc/pyomobook/ref-solvers/example500.py}{load5}{40}{43}

The \code{store\_to} method includes a single keyword argument,
\code{cuid}, whose default value is \code{False}.  If this argument
is \code{False}, then a string label is provided for each variable.
Hence the results object is suitable for human consumption;  it can be printed to provide
a YAML output of the solution.

If the \code{cuid} is \code{True}, then \textit{component unique
identifiers} (CUIDs) are used to label each variable.  A CUID
provides a compact, portable representation of a component within
a model.  This representation can be used to efficiently load
component data into a model.  In particular, this representation
is well-suited for contexts where solutions from one model are
loaded into another. For example:
\spacedlisting{pyomo/examples/doc/pyomobook/ref-solvers/example501.py}{run}{5}{20}


\section{Discussion}

The \code{pyro} and \code{phpyro} solver managers support the
analysis of Pyomo models across multiple cores and across distributed
compute clusters, using the Python \code{Pyro} software.  These
solver managers are stable, but they are not generally recommended
for advanced Pyomo users.

\index{solver I/O type!os}The solver I/O type for the COIN-OR
Optimization Services has been deprecated in Pyomo~\PyomoVersion.
This I/O type supports solvers that optimize with an OSiL file and
return a OSrL file generated by the solver.  This capability was
deprecated because few solvers rely on this I/O type.

